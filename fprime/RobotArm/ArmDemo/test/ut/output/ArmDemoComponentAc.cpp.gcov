        -:    0:Source:/mnt/c/Users/tcanham/source2/fprime/branches/nasa-timcanham/fprime/RobotArm/ArmDemo/ArmDemoComponentAc.cpp
        -:    0:Programs:18
        -:    1:// ======================================================================
        -:    2:// \title  ArmDemoComponentAc.cpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for ArmDemo component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   10://
        -:   11:// ======================================================================
        -:   12:
        -:   13:#include <stdio.h>
        -:   14:#include <Fw/Cfg/Config.hpp>
        -:   15:#include <RobotArm/ArmDemo/ArmDemoComponentAc.hpp>
        -:   16:#include <Fw/Types/Assert.hpp>
        -:   17:#if FW_ENABLE_TEXT_LOGGING
        -:   18:#include <Fw/Types/EightyCharString.hpp>
        -:   19:#endif
        -:   20:
        -:   21:
        -:   22:namespace RobotArm {
        -:   23:
        -:   24:  // ----------------------------------------------------------------------
        -:   25:  // Anonymous namespace to prevent name collisions
        -:   26:  // ----------------------------------------------------------------------
        -:   27:
        -:   28:  namespace {
        -:   29:
        -:   30:    typedef enum {
        -:   31:      ARMDEMO_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   32:      RUN_SCHED,
        -:   33:      CMD_AA_CLAW_ANG,
        -:   34:      CMD_AA_BASE_ANG,
        -:   35:      CMD_AA_ARM_HEIGHT_ANG,
        -:   36:      CMD_AA_ARM_LENGTH_ANG
        -:   37:    } MsgTypeEnum;
        -:   38:
        -:   39:    // Get the max size by doing a union of the input port serialization sizes.
        -:   40:
        -:   41:    typedef union {
        -:   42:      BYTE port1[Svc::InputSchedPort::SERIALIZED_SIZE];
        -:   43:      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
        -:   44:    } BuffUnion;
        -:   45:
        -:   46:    // Define a message buffer class large enough to handle all the
        -:   47:    // asynchronous inputs to the component
        -:   48:
     3348:   49:    class ComponentIpcSerializableBuffer :
        -:   50:      public Fw::SerializeBufferBase
        -:   51:    {
        -:   52:
        -:   53:      public:
        -:   54:
        -:   55:        enum {
        -:   56:          // Max. message size = size of data + message id + port
        -:   57:          SERIALIZATION_SIZE =
        -:   58:            sizeof(BuffUnion) +
        -:   59:            sizeof(NATIVE_INT_TYPE) +
        -:   60:            sizeof(NATIVE_INT_TYPE)
        -:   61:        };
        -:   62:
     4443:   63:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
     4443:   64:          return sizeof(m_buff);
        -:   65:        }
        -:   66:
    27667:   67:        U8* getBuffAddr(void) {
    27667:   68:          return m_buff;
        -:   69:        }
        -:   70:
      837:   71:        const U8* getBuffAddr(void) const {
      837:   72:          return m_buff;
        -:   73:        }
        -:   74:
        -:   75:      private:
        -:   76:        // Should be the max of all the input ports serialized sizes...
        -:   77:        U8 m_buff[SERIALIZATION_SIZE];
        -:   78:
        -:   79:    };
        -:   80:
        -:   81:  }
        -:   82:
        -:   83:  // ----------------------------------------------------------------------
        -:   84:  // Getters for numbers of input ports
        -:   85:  // ----------------------------------------------------------------------
        -:   86:
       31:   87:  Svc::InputSchedPort *ArmDemoComponentBase ::
        -:   88:    get_Run_InputPort(NATIVE_INT_TYPE portNum)
        -:   89:  {
       31:   90:    FW_ASSERT(portNum < this->getNum_Run_InputPorts(),static_cast<AssertArg>(portNum));
       31:   91:    return &this->m_Run_InputPort[portNum];
        -:   92:  }
        -:   93:
       31:   94:  Fw::InputCmdPort *ArmDemoComponentBase ::
        -:   95:    get_CmdDisp_InputPort(NATIVE_INT_TYPE portNum)
        -:   96:  {
       31:   97:    FW_ASSERT(portNum < this->getNum_CmdDisp_InputPorts(),static_cast<AssertArg>(portNum));
       31:   98:    return &this->m_CmdDisp_InputPort[portNum];
        -:   99:  }
        -:  100:
        -:  101:  // ----------------------------------------------------------------------
        -:  102:  // Typed connectors for output ports
        -:  103:  // ----------------------------------------------------------------------
        -:  104:
      124:  105:  void ArmDemoComponentBase ::
        -:  106:    set_position_OutputPort(
        -:  107:        NATIVE_INT_TYPE portNum,
        -:  108:        RobotArm::InputServoSetPort* port
        -:  109:    )
        -:  110:  {
      124:  111:    FW_ASSERT(portNum < this->getNum_position_OutputPorts(),static_cast<AssertArg>(portNum));
      124:  112:    this->m_position_OutputPort[portNum].addCallPort(port);
      124:  113:  }
        -:  114:
       31:  115:  void ArmDemoComponentBase ::
        -:  116:    set_CmdStatus_OutputPort(
        -:  117:        NATIVE_INT_TYPE portNum,
        -:  118:        Fw::InputCmdResponsePort* port
        -:  119:    )
        -:  120:  {
       31:  121:    FW_ASSERT(portNum < this->getNum_CmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
       31:  122:    this->m_CmdStatus_OutputPort[portNum].addCallPort(port);
       31:  123:  }
        -:  124:
       31:  125:  void ArmDemoComponentBase ::
        -:  126:    set_CmdReg_OutputPort(
        -:  127:        NATIVE_INT_TYPE portNum,
        -:  128:        Fw::InputCmdRegPort* port
        -:  129:    )
        -:  130:  {
       31:  131:    FW_ASSERT(portNum < this->getNum_CmdReg_OutputPorts(),static_cast<AssertArg>(portNum));
       31:  132:    this->m_CmdReg_OutputPort[portNum].addCallPort(port);
       31:  133:  }
        -:  134:
       31:  135:  void ArmDemoComponentBase ::
        -:  136:    set_Tlm_OutputPort(
        -:  137:        NATIVE_INT_TYPE portNum,
        -:  138:        Fw::InputTlmPort* port
        -:  139:    )
        -:  140:  {
       31:  141:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts(),static_cast<AssertArg>(portNum));
       31:  142:    this->m_Tlm_OutputPort[portNum].addCallPort(port);
       31:  143:  }
        -:  144:
       31:  145:  void ArmDemoComponentBase ::
        -:  146:    set_Time_OutputPort(
        -:  147:        NATIVE_INT_TYPE portNum,
        -:  148:        Fw::InputTimePort* port
        -:  149:    )
        -:  150:  {
       31:  151:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
       31:  152:    this->m_Time_OutputPort[portNum].addCallPort(port);
       31:  153:  }
        -:  154:
       31:  155:  void ArmDemoComponentBase ::
        -:  156:    set_Log_OutputPort(
        -:  157:        NATIVE_INT_TYPE portNum,
        -:  158:        Fw::InputLogPort* port
        -:  159:    )
        -:  160:  {
       31:  161:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts(),static_cast<AssertArg>(portNum));
       31:  162:    this->m_Log_OutputPort[portNum].addCallPort(port);
       31:  163:  }
        -:  164:
        -:  165:#if FW_ENABLE_TEXT_LOGGING == 1
       31:  166:  void ArmDemoComponentBase ::
        -:  167:    set_LogText_OutputPort(
        -:  168:        NATIVE_INT_TYPE portNum,
        -:  169:        Fw::InputLogTextPort* port
        -:  170:    )
        -:  171:  {
       31:  172:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
       31:  173:    this->m_LogText_OutputPort[portNum].addCallPort(port);
       31:  174:  }
        -:  175:#endif
        -:  176:
        -:  177:  // ----------------------------------------------------------------------
        -:  178:  // Serialization connectors for output ports
        -:  179:  // ----------------------------------------------------------------------
        -:  180:
        -:  181:#if FW_PORT_SERIALIZATION
        -:  182:
    #####:  183:  void ArmDemoComponentBase ::
        -:  184:    set_position_OutputPort(
        -:  185:        NATIVE_INT_TYPE portNum,
        -:  186:        Fw::InputSerializePort *port
        -:  187:    )
        -:  188:  {
    #####:  189:    FW_ASSERT(portNum < this->getNum_position_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  190:    return this->m_position_OutputPort[portNum].registerSerialPort(port);
        -:  191:  }
        -:  192:
    #####:  193:  void ArmDemoComponentBase ::
        -:  194:    set_CmdStatus_OutputPort(
        -:  195:        NATIVE_INT_TYPE portNum,
        -:  196:        Fw::InputSerializePort *port
        -:  197:    )
        -:  198:  {
    #####:  199:    FW_ASSERT(portNum < this->getNum_CmdStatus_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  200:    return this->m_CmdStatus_OutputPort[portNum].registerSerialPort(port);
        -:  201:  }
        -:  202:
    #####:  203:  void ArmDemoComponentBase ::
        -:  204:    set_CmdReg_OutputPort(
        -:  205:        NATIVE_INT_TYPE portNum,
        -:  206:        Fw::InputSerializePort *port
        -:  207:    )
        -:  208:  {
    #####:  209:    FW_ASSERT(portNum < this->getNum_CmdReg_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  210:    return this->m_CmdReg_OutputPort[portNum].registerSerialPort(port);
        -:  211:  }
        -:  212:
    #####:  213:  void ArmDemoComponentBase ::
        -:  214:    set_Tlm_OutputPort(
        -:  215:        NATIVE_INT_TYPE portNum,
        -:  216:        Fw::InputSerializePort *port
        -:  217:    )
        -:  218:  {
    #####:  219:    FW_ASSERT(portNum < this->getNum_Tlm_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  220:    return this->m_Tlm_OutputPort[portNum].registerSerialPort(port);
        -:  221:  }
        -:  222:
    #####:  223:  void ArmDemoComponentBase ::
        -:  224:    set_Time_OutputPort(
        -:  225:        NATIVE_INT_TYPE portNum,
        -:  226:        Fw::InputSerializePort *port
        -:  227:    )
        -:  228:  {
    #####:  229:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  230:    return this->m_Time_OutputPort[portNum].registerSerialPort(port);
        -:  231:  }
        -:  232:
    #####:  233:  void ArmDemoComponentBase ::
        -:  234:    set_Log_OutputPort(
        -:  235:        NATIVE_INT_TYPE portNum,
        -:  236:        Fw::InputSerializePort *port
        -:  237:    )
        -:  238:  {
    #####:  239:    FW_ASSERT(portNum < this->getNum_Log_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  240:    return this->m_Log_OutputPort[portNum].registerSerialPort(port);
        -:  241:  }
        -:  242:
        -:  243:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  244:  void ArmDemoComponentBase ::
        -:  245:    set_LogText_OutputPort(
        -:  246:        NATIVE_INT_TYPE portNum,
        -:  247:        Fw::InputSerializePort *port
        -:  248:    )
        -:  249:  {
    #####:  250:    FW_ASSERT(portNum < this->getNum_LogText_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  251:    return this->m_LogText_OutputPort[portNum].registerSerialPort(port);
        -:  252:  }
        -:  253:#endif
        -:  254:
        -:  255:#endif
        -:  256:
        -:  257:  // ----------------------------------------------------------------------
        -:  258:  // Command registration
        -:  259:  // ----------------------------------------------------------------------
        -:  260:
    #####:  261:  void ArmDemoComponentBase ::
        -:  262:    regCommands(void)
        -:  263:  {
    #####:  264:    FW_ASSERT(this->m_CmdReg_OutputPort[0].isConnected());
    #####:  265:    this->m_CmdReg_OutputPort[0].invoke(
        -:  266:        this->getIdBase() + OPCODE_AA_CLAW_ANG
        -:  267:    );
    #####:  268:    this->m_CmdReg_OutputPort[0].invoke(
    #####:  269:        this->getIdBase() + OPCODE_AA_BASE_ANG
        -:  270:    );
    #####:  271:    this->m_CmdReg_OutputPort[0].invoke(
    #####:  272:        this->getIdBase() + OPCODE_AA_ARM_HEIGHT_ANG
        -:  273:    );
    #####:  274:    this->m_CmdReg_OutputPort[0].invoke(
    #####:  275:        this->getIdBase() + OPCODE_AA_ARM_LENGTH_ANG
        -:  276:    );
    #####:  277:  }
        -:  278:
        -:  279:  // ----------------------------------------------------------------------
        -:  280:  // Component construction, initialization, and destruction
        -:  281:  // ----------------------------------------------------------------------
        -:  282:
       31:  283:  ArmDemoComponentBase ::
        -:  284:#if FW_OBJECT_NAMES == 1
       31:  285:    ArmDemoComponentBase(const char* compName) :
       31:  286:      Fw::ActiveComponentBase(compName)
        -:  287:#else
        -:  288:    ArmDemoComponentBase() :
        -:  289:      Fw::ActiveComponentBase()
        -:  290:#endif
        -:  291:  {
        -:  292:
        -:  293:
        -:  294:
       31:  295:  }
        -:  296:
       31:  297:  void ArmDemoComponentBase ::
        -:  298:    init(
        -:  299:        NATIVE_INT_TYPE queueDepth,
        -:  300:        NATIVE_INT_TYPE instance
        -:  301:    )
        -:  302:  {
        -:  303:
        -:  304:    // Initialize base class
       31:  305:    Fw::ActiveComponentBase::init(instance);
        -:  306:
        -:  307:    // Connect input port Run
       31:  308:    for (
       31:  309:        NATIVE_INT_TYPE port = 0;
       62:  310:        port < this->getNum_Run_InputPorts();
        -:  311:        port++
        -:  312:    ) {
        -:  313:
       31:  314:      this->m_Run_InputPort[port].init();
       31:  315:      this->m_Run_InputPort[port].addCallComp(
        -:  316:          this,
        -:  317:          m_p_Run_in
        -:  318:      );
       31:  319:      this->m_Run_InputPort[port].setPortNum(port);
        -:  320:
        -:  321:#if FW_OBJECT_NAMES == 1
        -:  322:      char portName[80];
       31:  323:      (void) snprintf(
        -:  324:          portName,
        -:  325:          sizeof(portName),
        -:  326:          "%s_Run_InputPort[%d]",
        -:  327:          this->m_objName,
        -:  328:          port
        -:  329:      );
       31:  330:      this->m_Run_InputPort[port].setObjName(portName);
        -:  331:#endif
        -:  332:
        -:  333:    }
        -:  334:
        -:  335:    // Connect input port CmdDisp
       31:  336:    for (
       31:  337:        NATIVE_INT_TYPE port = 0;
       62:  338:        port < this->getNum_CmdDisp_InputPorts();
        -:  339:        port++
        -:  340:    ) {
        -:  341:
       31:  342:      this->m_CmdDisp_InputPort[port].init();
       31:  343:      this->m_CmdDisp_InputPort[port].addCallComp(
        -:  344:          this,
        -:  345:          m_p_CmdDisp_in
        -:  346:      );
       31:  347:      this->m_CmdDisp_InputPort[port].setPortNum(port);
        -:  348:
        -:  349:#if FW_OBJECT_NAMES == 1
        -:  350:      char portName[80];
       31:  351:      (void) snprintf(
        -:  352:          portName,
        -:  353:          sizeof(portName),
        -:  354:          "%s_CmdDisp_InputPort[%d]",
        -:  355:          this->m_objName,
        -:  356:          port
        -:  357:      );
       31:  358:      this->m_CmdDisp_InputPort[port].setObjName(portName);
        -:  359:#endif
        -:  360:
        -:  361:    }
        -:  362:
        -:  363:    // Initialize output port position
      124:  364:    for (
       31:  365:        NATIVE_INT_TYPE port = 0;
      155:  366:        port < this->getNum_position_OutputPorts();
        -:  367:        port++
        -:  368:    ) {
      124:  369:      this->m_position_OutputPort[port].init();
        -:  370:
        -:  371:#if FW_OBJECT_NAMES == 1
        -:  372:      char portName[80];
      124:  373:      (void) snprintf(
        -:  374:          portName,
        -:  375:          sizeof(portName),
        -:  376:          "%s_position_OutputPort[%d]",
        -:  377:          this->m_objName,
        -:  378:          port
        -:  379:      );
      124:  380:      this->m_position_OutputPort[port].setObjName(portName);
        -:  381:#endif
        -:  382:
        -:  383:    }
        -:  384:
        -:  385:    // Initialize output port CmdStatus
       31:  386:    for (
       31:  387:        NATIVE_INT_TYPE port = 0;
       62:  388:        port < this->getNum_CmdStatus_OutputPorts();
        -:  389:        port++
        -:  390:    ) {
       31:  391:      this->m_CmdStatus_OutputPort[port].init();
        -:  392:
        -:  393:#if FW_OBJECT_NAMES == 1
        -:  394:      char portName[80];
       31:  395:      (void) snprintf(
        -:  396:          portName,
        -:  397:          sizeof(portName),
        -:  398:          "%s_CmdStatus_OutputPort[%d]",
        -:  399:          this->m_objName,
        -:  400:          port
        -:  401:      );
       31:  402:      this->m_CmdStatus_OutputPort[port].setObjName(portName);
        -:  403:#endif
        -:  404:
        -:  405:    }
        -:  406:
        -:  407:    // Initialize output port CmdReg
       31:  408:    for (
       31:  409:        NATIVE_INT_TYPE port = 0;
       62:  410:        port < this->getNum_CmdReg_OutputPorts();
        -:  411:        port++
        -:  412:    ) {
       31:  413:      this->m_CmdReg_OutputPort[port].init();
        -:  414:
        -:  415:#if FW_OBJECT_NAMES == 1
        -:  416:      char portName[80];
       31:  417:      (void) snprintf(
        -:  418:          portName,
        -:  419:          sizeof(portName),
        -:  420:          "%s_CmdReg_OutputPort[%d]",
        -:  421:          this->m_objName,
        -:  422:          port
        -:  423:      );
       31:  424:      this->m_CmdReg_OutputPort[port].setObjName(portName);
        -:  425:#endif
        -:  426:
        -:  427:    }
        -:  428:
        -:  429:    // Initialize output port Tlm
       31:  430:    for (
       31:  431:        NATIVE_INT_TYPE port = 0;
       62:  432:        port < this->getNum_Tlm_OutputPorts();
        -:  433:        port++
        -:  434:    ) {
       31:  435:      this->m_Tlm_OutputPort[port].init();
        -:  436:
        -:  437:#if FW_OBJECT_NAMES == 1
        -:  438:      char portName[80];
       31:  439:      (void) snprintf(
        -:  440:          portName,
        -:  441:          sizeof(portName),
        -:  442:          "%s_Tlm_OutputPort[%d]",
        -:  443:          this->m_objName,
        -:  444:          port
        -:  445:      );
       31:  446:      this->m_Tlm_OutputPort[port].setObjName(portName);
        -:  447:#endif
        -:  448:
        -:  449:    }
        -:  450:
        -:  451:    // Initialize output port Time
       31:  452:    for (
       31:  453:        NATIVE_INT_TYPE port = 0;
       62:  454:        port < this->getNum_Time_OutputPorts();
        -:  455:        port++
        -:  456:    ) {
       31:  457:      this->m_Time_OutputPort[port].init();
        -:  458:
        -:  459:#if FW_OBJECT_NAMES == 1
        -:  460:      char portName[80];
       31:  461:      (void) snprintf(
        -:  462:          portName,
        -:  463:          sizeof(portName),
        -:  464:          "%s_Time_OutputPort[%d]",
        -:  465:          this->m_objName,
        -:  466:          port
        -:  467:      );
       31:  468:      this->m_Time_OutputPort[port].setObjName(portName);
        -:  469:#endif
        -:  470:
        -:  471:    }
        -:  472:
        -:  473:    // Initialize output port Log
       31:  474:    for (
       31:  475:        NATIVE_INT_TYPE port = 0;
       62:  476:        port < this->getNum_Log_OutputPorts();
        -:  477:        port++
        -:  478:    ) {
       31:  479:      this->m_Log_OutputPort[port].init();
        -:  480:
        -:  481:#if FW_OBJECT_NAMES == 1
        -:  482:      char portName[80];
       31:  483:      (void) snprintf(
        -:  484:          portName,
        -:  485:          sizeof(portName),
        -:  486:          "%s_Log_OutputPort[%d]",
        -:  487:          this->m_objName,
        -:  488:          port
        -:  489:      );
       31:  490:      this->m_Log_OutputPort[port].setObjName(portName);
        -:  491:#endif
        -:  492:
        -:  493:    }
        -:  494:
        -:  495:    // Initialize output port LogText
        -:  496:#if FW_ENABLE_TEXT_LOGGING == 1
       31:  497:    for (
       31:  498:        NATIVE_INT_TYPE port = 0;
       62:  499:        port < this->getNum_LogText_OutputPorts();
        -:  500:        port++
        -:  501:    ) {
       31:  502:      this->m_LogText_OutputPort[port].init();
        -:  503:
        -:  504:#if FW_OBJECT_NAMES == 1
        -:  505:      char portName[80];
       31:  506:      (void) snprintf(
        -:  507:          portName,
        -:  508:          sizeof(portName),
        -:  509:          "%s_LogText_OutputPort[%d]",
        -:  510:          this->m_objName,
        -:  511:          port
        -:  512:      );
       31:  513:      this->m_LogText_OutputPort[port].setObjName(portName);
        -:  514:#endif
        -:  515:
        -:  516:    }
        -:  517:#endif
        -:  518:
        -:  519:    Os::Queue::QueueStatus qStat =
       31:  520:    this->createQueue(
        -:  521:        queueDepth,
        -:  522:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
       31:  523:    );
       31:  524:    FW_ASSERT(
        -:  525:        Os::Queue::QUEUE_OK == qStat,
        -:  526:        static_cast<AssertArg>(qStat)
        -:  527:    );
        -:  528:
       31:  529:  }
        -:  530:
       31:  531:  ArmDemoComponentBase::
       31:  532:    ~ArmDemoComponentBase() {
        -:  533:
       31:  534:  }
        -:  535:
        -:  536:  // ----------------------------------------------------------------------
        -:  537:  // Invocation functions for output ports
        -:  538:  // ----------------------------------------------------------------------
        -:  539:
       86:  540:  void ArmDemoComponentBase ::
        -:  541:    position_out(
        -:  542:        NATIVE_INT_TYPE portNum,
        -:  543:        F32 angle
        -:  544:    )
        -:  545:  {
       86:  546:    FW_ASSERT(portNum < this->getNum_position_OutputPorts(),static_cast<AssertArg>(portNum));
       86:  547:    this->m_position_OutputPort[portNum].invoke(angle);
       86:  548:  }
        -:  549:
        -:  550:  // ----------------------------------------------------------------------
        -:  551:  // Getters for numbers of ports
        -:  552:  // ----------------------------------------------------------------------
        -:  553:
      365:  554:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  555:    getNum_position_OutputPorts(void)
        -:  556:  {
      365:  557:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  558:        this->m_position_OutputPort
        -:  559:    );
        -:  560:  }
        -:  561:
      844:  562:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  563:    getNum_Run_InputPorts(void)
        -:  564:  {
      844:  565:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  566:        this->m_Run_InputPort
        -:  567:    );
        -:  568:  }
        -:  569:
       93:  570:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  571:    getNum_CmdDisp_InputPorts(void)
        -:  572:  {
       93:  573:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  574:        this->m_CmdDisp_InputPort
        -:  575:    );
        -:  576:  }
        -:  577:
       93:  578:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  579:    getNum_CmdStatus_OutputPorts(void)
        -:  580:  {
       93:  581:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  582:        this->m_CmdStatus_OutputPort
        -:  583:    );
        -:  584:  }
        -:  585:
       93:  586:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  587:    getNum_CmdReg_OutputPorts(void)
        -:  588:  {
       93:  589:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  590:        this->m_CmdReg_OutputPort
        -:  591:    );
        -:  592:  }
        -:  593:
       93:  594:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  595:    getNum_Tlm_OutputPorts(void)
        -:  596:  {
       93:  597:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  598:        this->m_Tlm_OutputPort
        -:  599:    );
        -:  600:  }
        -:  601:
       93:  602:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  603:    getNum_Time_OutputPorts(void)
        -:  604:  {
       93:  605:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  606:        this->m_Time_OutputPort
        -:  607:    );
        -:  608:  }
        -:  609:
       93:  610:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  611:    getNum_Log_OutputPorts(void)
        -:  612:  {
       93:  613:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  614:        this->m_Log_OutputPort
        -:  615:    );
        -:  616:  }
        -:  617:
        -:  618:#if FW_ENABLE_TEXT_LOGGING == 1
       93:  619:  NATIVE_INT_TYPE ArmDemoComponentBase ::
        -:  620:    getNum_LogText_OutputPorts(void)
        -:  621:  {
       93:  622:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  623:        this->m_LogText_OutputPort
        -:  624:    );
        -:  625:  }
        -:  626:#endif
        -:  627:
        -:  628:  // ----------------------------------------------------------------------
        -:  629:  // Port connection status queries
        -:  630:  // ----------------------------------------------------------------------
        -:  631:
    #####:  632:  bool ArmDemoComponentBase ::
        -:  633:    isConnected_position_OutputPort(NATIVE_INT_TYPE portNum)
        -:  634:  {
    #####:  635:     FW_ASSERT(
        -:  636:        portNum < this->getNum_position_OutputPorts(),
        -:  637:        static_cast<AssertArg>(portNum)
        -:  638:     );
    #####:  639:     return this->m_position_OutputPort[portNum].isConnected();
        -:  640:  }
        -:  641:
    #####:  642:  bool ArmDemoComponentBase ::
        -:  643:    isConnected_CmdStatus_OutputPort(NATIVE_INT_TYPE portNum)
        -:  644:  {
    #####:  645:     FW_ASSERT(
        -:  646:        portNum < this->getNum_CmdStatus_OutputPorts(),
        -:  647:        static_cast<AssertArg>(portNum)
        -:  648:     );
    #####:  649:     return this->m_CmdStatus_OutputPort[portNum].isConnected();
        -:  650:  }
        -:  651:
    #####:  652:  bool ArmDemoComponentBase ::
        -:  653:    isConnected_CmdReg_OutputPort(NATIVE_INT_TYPE portNum)
        -:  654:  {
    #####:  655:     FW_ASSERT(
        -:  656:        portNum < this->getNum_CmdReg_OutputPorts(),
        -:  657:        static_cast<AssertArg>(portNum)
        -:  658:     );
    #####:  659:     return this->m_CmdReg_OutputPort[portNum].isConnected();
        -:  660:  }
        -:  661:
    #####:  662:  bool ArmDemoComponentBase ::
        -:  663:    isConnected_Tlm_OutputPort(NATIVE_INT_TYPE portNum)
        -:  664:  {
    #####:  665:     FW_ASSERT(
        -:  666:        portNum < this->getNum_Tlm_OutputPorts(),
        -:  667:        static_cast<AssertArg>(portNum)
        -:  668:     );
    #####:  669:     return this->m_Tlm_OutputPort[portNum].isConnected();
        -:  670:  }
        -:  671:
    #####:  672:  bool ArmDemoComponentBase ::
        -:  673:    isConnected_Time_OutputPort(NATIVE_INT_TYPE portNum)
        -:  674:  {
    #####:  675:     FW_ASSERT(
        -:  676:        portNum < this->getNum_Time_OutputPorts(),
        -:  677:        static_cast<AssertArg>(portNum)
        -:  678:     );
    #####:  679:     return this->m_Time_OutputPort[portNum].isConnected();
        -:  680:  }
        -:  681:
    #####:  682:  bool ArmDemoComponentBase ::
        -:  683:    isConnected_Log_OutputPort(NATIVE_INT_TYPE portNum)
        -:  684:  {
    #####:  685:     FW_ASSERT(
        -:  686:        portNum < this->getNum_Log_OutputPorts(),
        -:  687:        static_cast<AssertArg>(portNum)
        -:  688:     );
    #####:  689:     return this->m_Log_OutputPort[portNum].isConnected();
        -:  690:  }
        -:  691:
        -:  692:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  693:  bool ArmDemoComponentBase ::
        -:  694:    isConnected_LogText_OutputPort(NATIVE_INT_TYPE portNum)
        -:  695:  {
    #####:  696:     FW_ASSERT(
        -:  697:        portNum < this->getNum_LogText_OutputPorts(),
        -:  698:        static_cast<AssertArg>(portNum)
        -:  699:     );
    #####:  700:     return this->m_LogText_OutputPort[portNum].isConnected();
        -:  701:  }
        -:  702:#endif
        -:  703:
        -:  704:  // ----------------------------------------------------------------------
        -:  705:  // Calls for messages received on command input ports
        -:  706:  // ----------------------------------------------------------------------
        -:  707:
       86:  708:  void ArmDemoComponentBase ::
        -:  709:    m_p_CmdDisp_in(
        -:  710:        Fw::PassiveComponentBase* callComp,
        -:  711:        NATIVE_INT_TYPE portNum,
        -:  712:        FwOpcodeType opCode,
        -:  713:        U32 cmdSeq,
        -:  714:        Fw::CmdArgBuffer &args
        -:  715:    )
        -:  716:  {
        -:  717:
        -:  718:    // Select base class function based on opcode
       86:  719:    FW_ASSERT(callComp);
       86:  720:    ArmDemoComponentBase* compPtr =
        -:  721:      (ArmDemoComponentBase*) callComp;
        -:  722:
       86:  723:    const U32 idBase = callComp->getIdBase();
       86:  724:    FW_ASSERT(opCode >= idBase, opCode, idBase);
       86:  725:    switch (opCode - idBase) {
        -:  726:
       34:  727:      case OPCODE_AA_CLAW_ANG: /*!< Claw angle command */
       34:  728:        compPtr->AA_CLAW_ANG_cmdHandlerBase(
        -:  729:            opCode,
        -:  730:            cmdSeq,
        -:  731:            args
        -:  732:        );
       34:  733:        break;
        -:  734:
       22:  735:      case OPCODE_AA_BASE_ANG: /*!< Base angle command */
       22:  736:        compPtr->AA_BASE_ANG_cmdHandlerBase(
        -:  737:            opCode,
        -:  738:            cmdSeq,
        -:  739:            args
        -:  740:        );
       22:  741:        break;
        -:  742:
       18:  743:      case OPCODE_AA_ARM_HEIGHT_ANG: /*!< Arm height angle command */
       18:  744:        compPtr->AA_ARM_HEIGHT_ANG_cmdHandlerBase(
        -:  745:            opCode,
        -:  746:            cmdSeq,
        -:  747:            args
        -:  748:        );
       18:  749:        break;
        -:  750:
       12:  751:      case OPCODE_AA_ARM_LENGTH_ANG: /*!< Arm length angle command */
       12:  752:        compPtr->AA_ARM_LENGTH_ANG_cmdHandlerBase(
        -:  753:            opCode,
        -:  754:            cmdSeq,
        -:  755:            args
        -:  756:        );
       12:  757:        break;
        -:  758:
    #####:  759:      default: {
    #####:  760:        compPtr->cmdResponse_out(
        -:  761:            opCode,cmdSeq,
        -:  762:            Fw::COMMAND_INVALID_OPCODE
        -:  763:        );
    #####:  764:        break;
        -:  765:      }
        -:  766:
        -:  767:    }
        -:  768:
       86:  769:  }
        -:  770:
       86:  771:  void ArmDemoComponentBase ::
        -:  772:    cmdResponse_out(
        -:  773:        FwOpcodeType opCode,
        -:  774:        U32 cmdSeq,
        -:  775:        Fw::CommandResponse response
        -:  776:    )
        -:  777:  {
       86:  778:    FW_ASSERT(this->m_CmdStatus_OutputPort[0].isConnected());
       86:  779:    this->m_CmdStatus_OutputPort[0].invoke(opCode,cmdSeq,response);
       86:  780:  }
        -:  781:
        -:  782:  // ----------------------------------------------------------------------
        -:  783:  // Base class command functions
        -:  784:  // ----------------------------------------------------------------------
        -:  785:
       34:  786:  void ArmDemoComponentBase ::
        -:  787:    AA_CLAW_ANG_cmdHandlerBase(
        -:  788:        FwOpcodeType opCode,
        -:  789:        U32 cmdSeq,
        -:  790:        Fw::CmdArgBuffer &args
        -:  791:    )
        -:  792:  {
        -:  793:
        -:  794:    // Call pre-message hook
       34:  795:    this->AA_CLAW_ANG_preMsgHook(opCode,cmdSeq);
        -:  796:
        -:  797:    // Defer deserializing arguments to the message dispatcher
        -:  798:    // to avoid deserializing and reserializing just for IPC
       68:  799:    ComponentIpcSerializableBuffer msg;
       34:  800:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  801:
        -:  802:    // Serialize for IPC
       34:  803:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_AA_CLAW_ANG);
       34:  804:    FW_ASSERT (
        -:  805:        _status == Fw::FW_SERIALIZE_OK,
        -:  806:        static_cast<AssertArg>(_status)
        -:  807:        );
        -:  808:
        -:  809:    // Fake port number to make message dequeue work
       34:  810:    NATIVE_INT_TYPE port = 0;
       34:  811:    _status = msg.serialize(port);
       34:  812:    FW_ASSERT (
        -:  813:        _status == Fw::FW_SERIALIZE_OK,
        -:  814:        static_cast<AssertArg>(_status)
        -:  815:    );
        -:  816:
       34:  817:    _status = msg.serialize(opCode);
       34:  818:    FW_ASSERT (
        -:  819:        _status == Fw::FW_SERIALIZE_OK,
        -:  820:        static_cast<AssertArg>(_status)
        -:  821:    );
        -:  822:
       34:  823:    _status = msg.serialize(cmdSeq);
       34:  824:    FW_ASSERT (
        -:  825:        _status == Fw::FW_SERIALIZE_OK,
        -:  826:        static_cast<AssertArg>(_status)
        -:  827:    );
        -:  828:
       34:  829:    _status = msg.serialize(args);
       34:  830:    FW_ASSERT (
        -:  831:        _status == Fw::FW_SERIALIZE_OK,
        -:  832:        static_cast<AssertArg>(_status)
        -:  833:    );
        -:  834:
        -:  835:    // send message
       34:  836:    Os::Queue::QueueBlocking _block =
        -:  837:      Os::Queue::QUEUE_NONBLOCKING;
        -:  838:    Os::Queue::QueueStatus qStatus =
       34:  839:      this->m_queue.send(msg, 0,_block);
       34:  840:    FW_ASSERT(
        -:  841:        qStatus == Os::Queue::QUEUE_OK,
        -:  842:        static_cast<AssertArg>(qStatus)
        -:  843:    );
        -:  844:
       34:  845:  }
        -:  846:
       34:  847:  void ArmDemoComponentBase::
        -:  848:    AA_CLAW_ANG_preMsgHook(
        -:  849:        FwOpcodeType opCode,
        -:  850:        U32 cmdSeq
        -:  851:    )
        -:  852:  {
        -:  853:    // Defaults to no-op; can be overridden
       34:  854:  }
        -:  855:
       22:  856:  void ArmDemoComponentBase ::
        -:  857:    AA_BASE_ANG_cmdHandlerBase(
        -:  858:        FwOpcodeType opCode,
        -:  859:        U32 cmdSeq,
        -:  860:        Fw::CmdArgBuffer &args
        -:  861:    )
        -:  862:  {
        -:  863:
        -:  864:    // Call pre-message hook
       22:  865:    this->AA_BASE_ANG_preMsgHook(opCode,cmdSeq);
        -:  866:
        -:  867:    // Defer deserializing arguments to the message dispatcher
        -:  868:    // to avoid deserializing and reserializing just for IPC
       44:  869:    ComponentIpcSerializableBuffer msg;
       22:  870:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  871:
        -:  872:    // Serialize for IPC
       22:  873:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_AA_BASE_ANG);
       22:  874:    FW_ASSERT (
        -:  875:        _status == Fw::FW_SERIALIZE_OK,
        -:  876:        static_cast<AssertArg>(_status)
        -:  877:        );
        -:  878:
        -:  879:    // Fake port number to make message dequeue work
       22:  880:    NATIVE_INT_TYPE port = 0;
       22:  881:    _status = msg.serialize(port);
       22:  882:    FW_ASSERT (
        -:  883:        _status == Fw::FW_SERIALIZE_OK,
        -:  884:        static_cast<AssertArg>(_status)
        -:  885:    );
        -:  886:
       22:  887:    _status = msg.serialize(opCode);
       22:  888:    FW_ASSERT (
        -:  889:        _status == Fw::FW_SERIALIZE_OK,
        -:  890:        static_cast<AssertArg>(_status)
        -:  891:    );
        -:  892:
       22:  893:    _status = msg.serialize(cmdSeq);
       22:  894:    FW_ASSERT (
        -:  895:        _status == Fw::FW_SERIALIZE_OK,
        -:  896:        static_cast<AssertArg>(_status)
        -:  897:    );
        -:  898:
       22:  899:    _status = msg.serialize(args);
       22:  900:    FW_ASSERT (
        -:  901:        _status == Fw::FW_SERIALIZE_OK,
        -:  902:        static_cast<AssertArg>(_status)
        -:  903:    );
        -:  904:
        -:  905:    // send message
       22:  906:    Os::Queue::QueueBlocking _block =
        -:  907:      Os::Queue::QUEUE_NONBLOCKING;
        -:  908:    Os::Queue::QueueStatus qStatus =
       22:  909:      this->m_queue.send(msg, 0,_block);
       22:  910:    FW_ASSERT(
        -:  911:        qStatus == Os::Queue::QUEUE_OK,
        -:  912:        static_cast<AssertArg>(qStatus)
        -:  913:    );
        -:  914:
       22:  915:  }
        -:  916:
       22:  917:  void ArmDemoComponentBase::
        -:  918:    AA_BASE_ANG_preMsgHook(
        -:  919:        FwOpcodeType opCode,
        -:  920:        U32 cmdSeq
        -:  921:    )
        -:  922:  {
        -:  923:    // Defaults to no-op; can be overridden
       22:  924:  }
        -:  925:
       18:  926:  void ArmDemoComponentBase ::
        -:  927:    AA_ARM_HEIGHT_ANG_cmdHandlerBase(
        -:  928:        FwOpcodeType opCode,
        -:  929:        U32 cmdSeq,
        -:  930:        Fw::CmdArgBuffer &args
        -:  931:    )
        -:  932:  {
        -:  933:
        -:  934:    // Call pre-message hook
       18:  935:    this->AA_ARM_HEIGHT_ANG_preMsgHook(opCode,cmdSeq);
        -:  936:
        -:  937:    // Defer deserializing arguments to the message dispatcher
        -:  938:    // to avoid deserializing and reserializing just for IPC
       36:  939:    ComponentIpcSerializableBuffer msg;
       18:  940:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  941:
        -:  942:    // Serialize for IPC
       18:  943:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_AA_ARM_HEIGHT_ANG);
       18:  944:    FW_ASSERT (
        -:  945:        _status == Fw::FW_SERIALIZE_OK,
        -:  946:        static_cast<AssertArg>(_status)
        -:  947:        );
        -:  948:
        -:  949:    // Fake port number to make message dequeue work
       18:  950:    NATIVE_INT_TYPE port = 0;
       18:  951:    _status = msg.serialize(port);
       18:  952:    FW_ASSERT (
        -:  953:        _status == Fw::FW_SERIALIZE_OK,
        -:  954:        static_cast<AssertArg>(_status)
        -:  955:    );
        -:  956:
       18:  957:    _status = msg.serialize(opCode);
       18:  958:    FW_ASSERT (
        -:  959:        _status == Fw::FW_SERIALIZE_OK,
        -:  960:        static_cast<AssertArg>(_status)
        -:  961:    );
        -:  962:
       18:  963:    _status = msg.serialize(cmdSeq);
       18:  964:    FW_ASSERT (
        -:  965:        _status == Fw::FW_SERIALIZE_OK,
        -:  966:        static_cast<AssertArg>(_status)
        -:  967:    );
        -:  968:
       18:  969:    _status = msg.serialize(args);
       18:  970:    FW_ASSERT (
        -:  971:        _status == Fw::FW_SERIALIZE_OK,
        -:  972:        static_cast<AssertArg>(_status)
        -:  973:    );
        -:  974:
        -:  975:    // send message
       18:  976:    Os::Queue::QueueBlocking _block =
        -:  977:      Os::Queue::QUEUE_NONBLOCKING;
        -:  978:    Os::Queue::QueueStatus qStatus =
       18:  979:      this->m_queue.send(msg, 0,_block);
       18:  980:    FW_ASSERT(
        -:  981:        qStatus == Os::Queue::QUEUE_OK,
        -:  982:        static_cast<AssertArg>(qStatus)
        -:  983:    );
        -:  984:
       18:  985:  }
        -:  986:
       18:  987:  void ArmDemoComponentBase::
        -:  988:    AA_ARM_HEIGHT_ANG_preMsgHook(
        -:  989:        FwOpcodeType opCode,
        -:  990:        U32 cmdSeq
        -:  991:    )
        -:  992:  {
        -:  993:    // Defaults to no-op; can be overridden
       18:  994:  }
        -:  995:
       12:  996:  void ArmDemoComponentBase ::
        -:  997:    AA_ARM_LENGTH_ANG_cmdHandlerBase(
        -:  998:        FwOpcodeType opCode,
        -:  999:        U32 cmdSeq,
        -: 1000:        Fw::CmdArgBuffer &args
        -: 1001:    )
        -: 1002:  {
        -: 1003:
        -: 1004:    // Call pre-message hook
       12: 1005:    this->AA_ARM_LENGTH_ANG_preMsgHook(opCode,cmdSeq);
        -: 1006:
        -: 1007:    // Defer deserializing arguments to the message dispatcher
        -: 1008:    // to avoid deserializing and reserializing just for IPC
       24: 1009:    ComponentIpcSerializableBuffer msg;
       12: 1010:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1011:
        -: 1012:    // Serialize for IPC
       12: 1013:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_AA_ARM_LENGTH_ANG);
       12: 1014:    FW_ASSERT (
        -: 1015:        _status == Fw::FW_SERIALIZE_OK,
        -: 1016:        static_cast<AssertArg>(_status)
        -: 1017:        );
        -: 1018:
        -: 1019:    // Fake port number to make message dequeue work
       12: 1020:    NATIVE_INT_TYPE port = 0;
       12: 1021:    _status = msg.serialize(port);
       12: 1022:    FW_ASSERT (
        -: 1023:        _status == Fw::FW_SERIALIZE_OK,
        -: 1024:        static_cast<AssertArg>(_status)
        -: 1025:    );
        -: 1026:
       12: 1027:    _status = msg.serialize(opCode);
       12: 1028:    FW_ASSERT (
        -: 1029:        _status == Fw::FW_SERIALIZE_OK,
        -: 1030:        static_cast<AssertArg>(_status)
        -: 1031:    );
        -: 1032:
       12: 1033:    _status = msg.serialize(cmdSeq);
       12: 1034:    FW_ASSERT (
        -: 1035:        _status == Fw::FW_SERIALIZE_OK,
        -: 1036:        static_cast<AssertArg>(_status)
        -: 1037:    );
        -: 1038:
       12: 1039:    _status = msg.serialize(args);
       12: 1040:    FW_ASSERT (
        -: 1041:        _status == Fw::FW_SERIALIZE_OK,
        -: 1042:        static_cast<AssertArg>(_status)
        -: 1043:    );
        -: 1044:
        -: 1045:    // send message
       12: 1046:    Os::Queue::QueueBlocking _block =
        -: 1047:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1048:    Os::Queue::QueueStatus qStatus =
       12: 1049:      this->m_queue.send(msg, 0,_block);
       12: 1050:    FW_ASSERT(
        -: 1051:        qStatus == Os::Queue::QUEUE_OK,
        -: 1052:        static_cast<AssertArg>(qStatus)
        -: 1053:    );
        -: 1054:
       12: 1055:  }
        -: 1056:
       12: 1057:  void ArmDemoComponentBase::
        -: 1058:    AA_ARM_LENGTH_ANG_preMsgHook(
        -: 1059:        FwOpcodeType opCode,
        -: 1060:        U32 cmdSeq
        -: 1061:    )
        -: 1062:  {
        -: 1063:    // Defaults to no-op; can be overridden
       12: 1064:  }
        -: 1065:
        -: 1066:  // ----------------------------------------------------------------------
        -: 1067:  // Telemetry write functions
        -: 1068:  // ----------------------------------------------------------------------
        -: 1069:
       34: 1070:  void ArmDemoComponentBase ::
        -: 1071:    tlmWrite_AA_ClawAngle(F32 arg)
        -: 1072:  {
        -: 1073:
       34: 1074:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       68: 1075:      Fw::Time _tlmTime;
       34: 1076:      if (this->m_Time_OutputPort[0].isConnected()) {
       34: 1077:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1078:      }
       68: 1079:      Fw::TlmBuffer _tlmBuff;
       34: 1080:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
       34: 1081:      FW_ASSERT(
        -: 1082:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1083:          static_cast<AssertArg>(_stat)
        -: 1084:      );
        -: 1085:
        -: 1086:      FwChanIdType _id;
        -: 1087:
       34: 1088:      _id = this->getIdBase() + CHANNELID_AA_CLAWANGLE;
        -: 1089:
       34: 1090:      this->m_Tlm_OutputPort[0].invoke(
        -: 1091:          _id,
        -: 1092:          _tlmTime,
        -: 1093:          _tlmBuff
        -: 1094:      );
        -: 1095:    }
        -: 1096:
       34: 1097:  }
        -: 1098:
       22: 1099:  void ArmDemoComponentBase ::
        -: 1100:    tlmWrite_AA_BaseAngle(F32 arg)
        -: 1101:  {
        -: 1102:
       22: 1103:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       44: 1104:      Fw::Time _tlmTime;
       22: 1105:      if (this->m_Time_OutputPort[0].isConnected()) {
       22: 1106:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1107:      }
       44: 1108:      Fw::TlmBuffer _tlmBuff;
       22: 1109:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
       22: 1110:      FW_ASSERT(
        -: 1111:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1112:          static_cast<AssertArg>(_stat)
        -: 1113:      );
        -: 1114:
        -: 1115:      FwChanIdType _id;
        -: 1116:
       22: 1117:      _id = this->getIdBase() + CHANNELID_AA_BASEANGLE;
        -: 1118:
       22: 1119:      this->m_Tlm_OutputPort[0].invoke(
        -: 1120:          _id,
        -: 1121:          _tlmTime,
        -: 1122:          _tlmBuff
        -: 1123:      );
        -: 1124:    }
        -: 1125:
       22: 1126:  }
        -: 1127:
       24: 1128:  void ArmDemoComponentBase ::
        -: 1129:    tlmWrite_AA_ArmHeightAngle(F32 arg)
        -: 1130:  {
        -: 1131:
       24: 1132:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       48: 1133:      Fw::Time _tlmTime;
       24: 1134:      if (this->m_Time_OutputPort[0].isConnected()) {
       24: 1135:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1136:      }
       48: 1137:      Fw::TlmBuffer _tlmBuff;
       24: 1138:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
       24: 1139:      FW_ASSERT(
        -: 1140:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1141:          static_cast<AssertArg>(_stat)
        -: 1142:      );
        -: 1143:
        -: 1144:      FwChanIdType _id;
        -: 1145:
       24: 1146:      _id = this->getIdBase() + CHANNELID_AA_ARMHEIGHTANGLE;
        -: 1147:
       24: 1148:      this->m_Tlm_OutputPort[0].invoke(
        -: 1149:          _id,
        -: 1150:          _tlmTime,
        -: 1151:          _tlmBuff
        -: 1152:      );
        -: 1153:    }
        -: 1154:
       24: 1155:  }
        -: 1156:
        6: 1157:  void ArmDemoComponentBase ::
        -: 1158:    tlmWrite_AA_ArmLengthAngle(F32 arg)
        -: 1159:  {
        -: 1160:
        6: 1161:    if (this->m_Tlm_OutputPort[0].isConnected()) {
       12: 1162:      Fw::Time _tlmTime;
        6: 1163:      if (this->m_Time_OutputPort[0].isConnected()) {
        6: 1164:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1165:      }
       12: 1166:      Fw::TlmBuffer _tlmBuff;
        6: 1167:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        6: 1168:      FW_ASSERT(
        -: 1169:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1170:          static_cast<AssertArg>(_stat)
        -: 1171:      );
        -: 1172:
        -: 1173:      FwChanIdType _id;
        -: 1174:
        6: 1175:      _id = this->getIdBase() + CHANNELID_AA_ARMLENGTHANGLE;
        -: 1176:
        6: 1177:      this->m_Tlm_OutputPort[0].invoke(
        -: 1178:          _id,
        -: 1179:          _tlmTime,
        -: 1180:          _tlmBuff
        -: 1181:      );
        -: 1182:    }
        -: 1183:
        6: 1184:  }
        -: 1185:
      751: 1186:  void ArmDemoComponentBase ::
        -: 1187:    tlmWrite_AA_Cycles(U32 arg)
        -: 1188:  {
        -: 1189:
      751: 1190:    if (this->m_Tlm_OutputPort[0].isConnected()) {
     1502: 1191:      Fw::Time _tlmTime;
      751: 1192:      if (this->m_Time_OutputPort[0].isConnected()) {
      751: 1193:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1194:      }
     1502: 1195:      Fw::TlmBuffer _tlmBuff;
      751: 1196:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
      751: 1197:      FW_ASSERT(
        -: 1198:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1199:          static_cast<AssertArg>(_stat)
        -: 1200:      );
        -: 1201:
        -: 1202:      FwChanIdType _id;
        -: 1203:
      751: 1204:      _id = this->getIdBase() + CHANNELID_AA_CYCLES;
        -: 1205:
      751: 1206:      this->m_Tlm_OutputPort[0].invoke(
        -: 1207:          _id,
        -: 1208:          _tlmTime,
        -: 1209:          _tlmBuff
        -: 1210:      );
        -: 1211:    }
        -: 1212:
      751: 1213:  }
        -: 1214:
        -: 1215:  // ----------------------------------------------------------------------
        -: 1216:  // Time
        -: 1217:  // ----------------------------------------------------------------------
        -: 1218:
    #####: 1219:  Fw::Time ArmDemoComponentBase ::
        -: 1220:    getTime(void)
        -: 1221:  {
    #####: 1222:    if (this->m_Time_OutputPort[0].isConnected()) {
    #####: 1223:      Fw::Time _time;
    #####: 1224:      this->m_Time_OutputPort[0].invoke(_time);
    #####: 1225:      return _time;
        -: 1226:    } else {
    #####: 1227:      return Fw::Time(TB_NONE,0,0);
        -: 1228:    }
        -: 1229:  }
        -: 1230:
        -: 1231:  // ----------------------------------------------------------------------
        -: 1232:  // Event handling functions
        -: 1233:  // ----------------------------------------------------------------------
        -: 1234:
       34: 1235:  void ArmDemoComponentBase ::
        -: 1236:    log_ACTIVITY_HI_AA_ClawAngleCmd(
        -: 1237:        F32 angle
        -: 1238:    )
        -: 1239:  {
        -: 1240:
        -: 1241:
        -: 1242:    // Get the time
       68: 1243:    Fw::Time _logTime;
       34: 1244:    if (this->m_Time_OutputPort[0].isConnected()) {
       34: 1245:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1246:    }
        -: 1247:
       34: 1248:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1249:
       34: 1250:    _id = this->getIdBase() + EVENTID_AA_CLAWANGLECMD;
        -: 1251:
        -: 1252:    // Emit the event on the log port
       34: 1253:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1254:
       68: 1255:      Fw::LogBuffer _logBuff;
       34: 1256:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1257:
        -: 1258:#if FW_AMPCS_COMPATIBLE
        -: 1259:      // Serialize the number of arguments
        -: 1260:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1261:      FW_ASSERT(
        -: 1262:          _status == Fw::FW_SERIALIZE_OK,
        -: 1263:          static_cast<AssertArg>(_status)
        -: 1264:      );
        -: 1265:#endif
        -: 1266:
        -: 1267:#if FW_AMPCS_COMPATIBLE
        -: 1268:      // Serialize the argument size
        -: 1269:      _status = _logBuff.serialize(
        -: 1270:          static_cast<U8>(sizeof(angle))
        -: 1271:      );
        -: 1272:      FW_ASSERT(
        -: 1273:          _status == Fw::FW_SERIALIZE_OK,
        -: 1274:          static_cast<AssertArg>(_status)
        -: 1275:      );
        -: 1276:#endif
        -: 1277:
       34: 1278:      _status = _logBuff.serialize(angle);
       34: 1279:      FW_ASSERT(
        -: 1280:          _status == Fw::FW_SERIALIZE_OK,
        -: 1281:          static_cast<AssertArg>(_status)
        -: 1282:      );
        -: 1283:
        -: 1284:
       34: 1285:      this->m_Log_OutputPort[0].invoke(
        -: 1286:          _id,
        -: 1287:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1288:          _logBuff
        -: 1289:      );
        -: 1290:
        -: 1291:    }
        -: 1292:
        -: 1293:    // Emit the event on the text log port
        -: 1294:#if FW_ENABLE_TEXT_LOGGING
       34: 1295:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1296:
        -: 1297:#if FW_OBJECT_NAMES == 1
       34: 1298:      const char* _formatString =
        -: 1299:        "(%s) %s: Claw commanded to %f";
        -: 1300:#else
        -: 1301:      const char* _formatString =
        -: 1302:        "%s: Claw commanded to %f";
        -: 1303:#endif
        -: 1304:
        -: 1305:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1306:
       34: 1307:      (void) snprintf(
        -: 1308:          _textBuffer,
        -: 1309:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1310:          _formatString,
        -: 1311:#if FW_OBJECT_NAMES == 1
        -: 1312:          this->m_objName,
        -: 1313:#endif
        -: 1314:          "AA_ClawAngleCmd "
        -: 1315:        , angle
        -: 1316:      );
        -: 1317:
        -: 1318:      // Null terminate
       34: 1319:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       68: 1320:      Fw::TextLogString _logString = _textBuffer;
       34: 1321:      this->m_LogText_OutputPort[0].invoke(
        -: 1322:          _id,
        -: 1323:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1324:          _logString
        -: 1325:      );
        -: 1326:
        -: 1327:    }
        -: 1328:#endif
        -: 1329:
       34: 1330:  }
        -: 1331:
        -: 1332:
       22: 1333:  void ArmDemoComponentBase ::
        -: 1334:    log_ACTIVITY_HI_AA_BaseAngleCmd(
        -: 1335:        F32 angle
        -: 1336:    )
        -: 1337:  {
        -: 1338:
        -: 1339:
        -: 1340:    // Get the time
       44: 1341:    Fw::Time _logTime;
       22: 1342:    if (this->m_Time_OutputPort[0].isConnected()) {
       22: 1343:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1344:    }
        -: 1345:
       22: 1346:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1347:
       22: 1348:    _id = this->getIdBase() + EVENTID_AA_BASEANGLECMD;
        -: 1349:
        -: 1350:    // Emit the event on the log port
       22: 1351:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1352:
       44: 1353:      Fw::LogBuffer _logBuff;
       22: 1354:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1355:
        -: 1356:#if FW_AMPCS_COMPATIBLE
        -: 1357:      // Serialize the number of arguments
        -: 1358:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1359:      FW_ASSERT(
        -: 1360:          _status == Fw::FW_SERIALIZE_OK,
        -: 1361:          static_cast<AssertArg>(_status)
        -: 1362:      );
        -: 1363:#endif
        -: 1364:
        -: 1365:#if FW_AMPCS_COMPATIBLE
        -: 1366:      // Serialize the argument size
        -: 1367:      _status = _logBuff.serialize(
        -: 1368:          static_cast<U8>(sizeof(angle))
        -: 1369:      );
        -: 1370:      FW_ASSERT(
        -: 1371:          _status == Fw::FW_SERIALIZE_OK,
        -: 1372:          static_cast<AssertArg>(_status)
        -: 1373:      );
        -: 1374:#endif
        -: 1375:
       22: 1376:      _status = _logBuff.serialize(angle);
       22: 1377:      FW_ASSERT(
        -: 1378:          _status == Fw::FW_SERIALIZE_OK,
        -: 1379:          static_cast<AssertArg>(_status)
        -: 1380:      );
        -: 1381:
        -: 1382:
       22: 1383:      this->m_Log_OutputPort[0].invoke(
        -: 1384:          _id,
        -: 1385:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1386:          _logBuff
        -: 1387:      );
        -: 1388:
        -: 1389:    }
        -: 1390:
        -: 1391:    // Emit the event on the text log port
        -: 1392:#if FW_ENABLE_TEXT_LOGGING
       22: 1393:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1394:
        -: 1395:#if FW_OBJECT_NAMES == 1
       22: 1396:      const char* _formatString =
        -: 1397:        "(%s) %s: Base commanded to %f";
        -: 1398:#else
        -: 1399:      const char* _formatString =
        -: 1400:        "%s: Base commanded to %f";
        -: 1401:#endif
        -: 1402:
        -: 1403:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1404:
       22: 1405:      (void) snprintf(
        -: 1406:          _textBuffer,
        -: 1407:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1408:          _formatString,
        -: 1409:#if FW_OBJECT_NAMES == 1
        -: 1410:          this->m_objName,
        -: 1411:#endif
        -: 1412:          "AA_BaseAngleCmd "
        -: 1413:        , angle
        -: 1414:      );
        -: 1415:
        -: 1416:      // Null terminate
       22: 1417:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       44: 1418:      Fw::TextLogString _logString = _textBuffer;
       22: 1419:      this->m_LogText_OutputPort[0].invoke(
        -: 1420:          _id,
        -: 1421:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1422:          _logString
        -: 1423:      );
        -: 1424:
        -: 1425:    }
        -: 1426:#endif
        -: 1427:
       22: 1428:  }
        -: 1429:
        -: 1430:
        6: 1431:  void ArmDemoComponentBase ::
        -: 1432:    log_ACTIVITY_HI_AA_ArmLengthAngleCmd(
        -: 1433:        F32 angle
        -: 1434:    )
        -: 1435:  {
        -: 1436:
        -: 1437:
        -: 1438:    // Get the time
       12: 1439:    Fw::Time _logTime;
        6: 1440:    if (this->m_Time_OutputPort[0].isConnected()) {
        6: 1441:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1442:    }
        -: 1443:
        6: 1444:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1445:
        6: 1446:    _id = this->getIdBase() + EVENTID_AA_ARMLENGTHANGLECMD;
        -: 1447:
        -: 1448:    // Emit the event on the log port
        6: 1449:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1450:
       12: 1451:      Fw::LogBuffer _logBuff;
        6: 1452:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1453:
        -: 1454:#if FW_AMPCS_COMPATIBLE
        -: 1455:      // Serialize the number of arguments
        -: 1456:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1457:      FW_ASSERT(
        -: 1458:          _status == Fw::FW_SERIALIZE_OK,
        -: 1459:          static_cast<AssertArg>(_status)
        -: 1460:      );
        -: 1461:#endif
        -: 1462:
        -: 1463:#if FW_AMPCS_COMPATIBLE
        -: 1464:      // Serialize the argument size
        -: 1465:      _status = _logBuff.serialize(
        -: 1466:          static_cast<U8>(sizeof(angle))
        -: 1467:      );
        -: 1468:      FW_ASSERT(
        -: 1469:          _status == Fw::FW_SERIALIZE_OK,
        -: 1470:          static_cast<AssertArg>(_status)
        -: 1471:      );
        -: 1472:#endif
        -: 1473:
        6: 1474:      _status = _logBuff.serialize(angle);
        6: 1475:      FW_ASSERT(
        -: 1476:          _status == Fw::FW_SERIALIZE_OK,
        -: 1477:          static_cast<AssertArg>(_status)
        -: 1478:      );
        -: 1479:
        -: 1480:
        6: 1481:      this->m_Log_OutputPort[0].invoke(
        -: 1482:          _id,
        -: 1483:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1484:          _logBuff
        -: 1485:      );
        -: 1486:
        -: 1487:    }
        -: 1488:
        -: 1489:    // Emit the event on the text log port
        -: 1490:#if FW_ENABLE_TEXT_LOGGING
        6: 1491:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1492:
        -: 1493:#if FW_OBJECT_NAMES == 1
        6: 1494:      const char* _formatString =
        -: 1495:        "(%s) %s: Arm length commanded to %f";
        -: 1496:#else
        -: 1497:      const char* _formatString =
        -: 1498:        "%s: Arm length commanded to %f";
        -: 1499:#endif
        -: 1500:
        -: 1501:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1502:
        6: 1503:      (void) snprintf(
        -: 1504:          _textBuffer,
        -: 1505:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1506:          _formatString,
        -: 1507:#if FW_OBJECT_NAMES == 1
        -: 1508:          this->m_objName,
        -: 1509:#endif
        -: 1510:          "AA_ArmLengthAngleCmd "
        -: 1511:        , angle
        -: 1512:      );
        -: 1513:
        -: 1514:      // Null terminate
        6: 1515:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       12: 1516:      Fw::TextLogString _logString = _textBuffer;
        6: 1517:      this->m_LogText_OutputPort[0].invoke(
        -: 1518:          _id,
        -: 1519:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1520:          _logString
        -: 1521:      );
        -: 1522:
        -: 1523:    }
        -: 1524:#endif
        -: 1525:
        6: 1526:  }
        -: 1527:
        -: 1528:
       24: 1529:  void ArmDemoComponentBase ::
        -: 1530:    log_ACTIVITY_HI_AA_ArmHeightAngleCmd(
        -: 1531:        F32 angle
        -: 1532:    )
        -: 1533:  {
        -: 1534:
        -: 1535:
        -: 1536:    // Get the time
       48: 1537:    Fw::Time _logTime;
       24: 1538:    if (this->m_Time_OutputPort[0].isConnected()) {
       24: 1539:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1540:    }
        -: 1541:
       24: 1542:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1543:
       24: 1544:    _id = this->getIdBase() + EVENTID_AA_ARMHEIGHTANGLECMD;
        -: 1545:
        -: 1546:    // Emit the event on the log port
       24: 1547:    if (this->m_Log_OutputPort[0].isConnected()) {
        -: 1548:
       48: 1549:      Fw::LogBuffer _logBuff;
       24: 1550:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1551:
        -: 1552:#if FW_AMPCS_COMPATIBLE
        -: 1553:      // Serialize the number of arguments
        -: 1554:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1555:      FW_ASSERT(
        -: 1556:          _status == Fw::FW_SERIALIZE_OK,
        -: 1557:          static_cast<AssertArg>(_status)
        -: 1558:      );
        -: 1559:#endif
        -: 1560:
        -: 1561:#if FW_AMPCS_COMPATIBLE
        -: 1562:      // Serialize the argument size
        -: 1563:      _status = _logBuff.serialize(
        -: 1564:          static_cast<U8>(sizeof(angle))
        -: 1565:      );
        -: 1566:      FW_ASSERT(
        -: 1567:          _status == Fw::FW_SERIALIZE_OK,
        -: 1568:          static_cast<AssertArg>(_status)
        -: 1569:      );
        -: 1570:#endif
        -: 1571:
       24: 1572:      _status = _logBuff.serialize(angle);
       24: 1573:      FW_ASSERT(
        -: 1574:          _status == Fw::FW_SERIALIZE_OK,
        -: 1575:          static_cast<AssertArg>(_status)
        -: 1576:      );
        -: 1577:
        -: 1578:
       24: 1579:      this->m_Log_OutputPort[0].invoke(
        -: 1580:          _id,
        -: 1581:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1582:          _logBuff
        -: 1583:      );
        -: 1584:
        -: 1585:    }
        -: 1586:
        -: 1587:    // Emit the event on the text log port
        -: 1588:#if FW_ENABLE_TEXT_LOGGING
       24: 1589:    if (this->m_LogText_OutputPort[0].isConnected()) {
        -: 1590:
        -: 1591:#if FW_OBJECT_NAMES == 1
       24: 1592:      const char* _formatString =
        -: 1593:        "(%s) %s: Arm height commanded to %f";
        -: 1594:#else
        -: 1595:      const char* _formatString =
        -: 1596:        "%s: Arm height commanded to %f";
        -: 1597:#endif
        -: 1598:
        -: 1599:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1600:
       24: 1601:      (void) snprintf(
        -: 1602:          _textBuffer,
        -: 1603:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1604:          _formatString,
        -: 1605:#if FW_OBJECT_NAMES == 1
        -: 1606:          this->m_objName,
        -: 1607:#endif
        -: 1608:          "AA_ArmHeightAngleCmd "
        -: 1609:        , angle
        -: 1610:      );
        -: 1611:
        -: 1612:      // Null terminate
       24: 1613:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       48: 1614:      Fw::TextLogString _logString = _textBuffer;
       24: 1615:      this->m_LogText_OutputPort[0].invoke(
        -: 1616:          _id,
        -: 1617:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1618:          _logString
        -: 1619:      );
        -: 1620:
        -: 1621:    }
        -: 1622:#endif
        -: 1623:
       24: 1624:  }
        -: 1625:
        -: 1626:
        -: 1627:  // ----------------------------------------------------------------------
        -: 1628:  // Calls for invocations received on typed input ports
        -: 1629:  // ----------------------------------------------------------------------
        -: 1630:
      751: 1631:  void ArmDemoComponentBase ::
        -: 1632:    m_p_Run_in(
        -: 1633:        Fw::PassiveComponentBase* callComp,
        -: 1634:        NATIVE_INT_TYPE portNum,
        -: 1635:        NATIVE_UINT_TYPE context
        -: 1636:    )
        -: 1637:  {
      751: 1638:    FW_ASSERT(callComp);
      751: 1639:    ArmDemoComponentBase* compPtr =
        -: 1640:      (ArmDemoComponentBase*) callComp;
      751: 1641:    compPtr->Run_handlerBase(portNum, context);
      751: 1642:  }
        -: 1643:
        -: 1644:  // ----------------------------------------------------------------------
        -: 1645:  // Port handler base-class functions for typed input ports
        -: 1646:  // ----------------------------------------------------------------------
        -: 1647:
      751: 1648:  void ArmDemoComponentBase ::
        -: 1649:    Run_handlerBase(
        -: 1650:        NATIVE_INT_TYPE portNum,
        -: 1651:        NATIVE_UINT_TYPE context
        -: 1652:    )
        -: 1653:  {
        -: 1654:
        -: 1655:    // Make sure port number is valid
      751: 1656:    FW_ASSERT(portNum < this->getNum_Run_InputPorts(),static_cast<AssertArg>(portNum));
        -: 1657:
        -: 1658:    // Call pre-message hook
      751: 1659:    Run_preMsgHook(
        -: 1660:        portNum,
        -: 1661:        context
      751: 1662:    );
        -: 1663:
     1502: 1664:    ComponentIpcSerializableBuffer msg;
      751: 1665:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1666:
      751: 1667:    _status = msg.serialize(
        -: 1668:        static_cast<NATIVE_INT_TYPE>(RUN_SCHED)
        -: 1669:    );
      751: 1670:    FW_ASSERT (
        -: 1671:        _status == Fw::FW_SERIALIZE_OK,
        -: 1672:        static_cast<AssertArg>(_status)
        -: 1673:    );
        -: 1674:
      751: 1675:    _status = msg.serialize(portNum);
      751: 1676:    FW_ASSERT (
        -: 1677:        _status == Fw::FW_SERIALIZE_OK,
        -: 1678:        static_cast<AssertArg>(_status)
        -: 1679:    );
        -: 1680:
        -: 1681:    // Serialize argument context
      751: 1682:    _status = msg.serialize(context);
      751: 1683:    FW_ASSERT(
        -: 1684:        _status == Fw::FW_SERIALIZE_OK,
        -: 1685:        static_cast<AssertArg>(_status)
        -: 1686:    );
        -: 1687:
        -: 1688:
        -: 1689:    // send message
      751: 1690:    Os::Queue::QueueBlocking _block =
        -: 1691:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1692:    Os::Queue::QueueStatus qStatus =
      751: 1693:      this->m_queue.send(msg, 0,_block);
      751: 1694:    FW_ASSERT(
        -: 1695:        qStatus == Os::Queue::QUEUE_OK,
        -: 1696:        static_cast<AssertArg>(qStatus)
        -: 1697:    );
        -: 1698:
      751: 1699:  }
        -: 1700:
        -: 1701:  // ----------------------------------------------------------------------
        -: 1702:  // Pre-message hooks for async input ports
        -: 1703:  // ----------------------------------------------------------------------
        -: 1704:
      751: 1705:  void ArmDemoComponentBase ::
        -: 1706:    Run_preMsgHook(
        -: 1707:        NATIVE_INT_TYPE portNum,
        -: 1708:        NATIVE_UINT_TYPE context
        -: 1709:    )
        -: 1710:  {
        -: 1711:    // Default: no-op
      751: 1712:  }
        -: 1713:
        -: 1714:  // ----------------------------------------------------------------------
        -: 1715:  // Message dispatch method for active and queued components. Called
        -: 1716:  // by active component thread or implementation code for queued components
        -: 1717:  // ----------------------------------------------------------------------
        -: 1718:
      837: 1719:  Fw::QueuedComponentBase::MsgDispatchStatus ArmDemoComponentBase ::
        -: 1720:    doDispatch(void)
        -: 1721:  {
     1674: 1722:    ComponentIpcSerializableBuffer msg;
        -: 1723:    NATIVE_INT_TYPE priority;
        -: 1724:
      837: 1725:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_BLOCKING);
      837: 1726:    FW_ASSERT(
        -: 1727:        msgStatus == Os::Queue::QUEUE_OK,
        -: 1728:        static_cast<AssertArg>(msgStatus)
        -: 1729:    );
        -: 1730:
        -: 1731:    // Reset to beginning of buffer
      837: 1732:    msg.resetDeser();
        -: 1733:
        -: 1734:    NATIVE_INT_TYPE desMsg;
      837: 1735:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
      837: 1736:    FW_ASSERT(
        -: 1737:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1738:        static_cast<AssertArg>(deserStatus)
        -: 1739:    );
        -: 1740:
      837: 1741:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -: 1742:
      837: 1743:    if (msgType == ARMDEMO_COMPONENT_EXIT) {
    #####: 1744:      return MSG_DISPATCH_EXIT;
        -: 1745:    }
        -: 1746:
        -: 1747:    NATIVE_INT_TYPE portNum;
      837: 1748:    deserStatus = msg.deserialize(portNum);
      837: 1749:    FW_ASSERT(
        -: 1750:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1751:        static_cast<AssertArg>(deserStatus)
        -: 1752:    );
        -: 1753:
      837: 1754:    switch (msgType) {
        -: 1755:
        -: 1756:      // Handle async input port Run
      751: 1757:      case RUN_SCHED: {
        -: 1758:
        -: 1759:        // Deserialize argument context
        -: 1760:        NATIVE_UINT_TYPE context;
      751: 1761:        deserStatus = msg.deserialize(context);
      751: 1762:        FW_ASSERT(
        -: 1763:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1764:            static_cast<AssertArg>(deserStatus)
        -: 1765:        );
        -: 1766:
        -: 1767:        // Call handler function
      751: 1768:        this->Run_handler(
        -: 1769:            portNum,
        -: 1770:            context
      751: 1771:        );
        -: 1772:
      751: 1773:        break;
        -: 1774:
        -: 1775:      }
        -: 1776:
        -: 1777:      // Handle command AA_CLAW_ANG
       34: 1778:      case CMD_AA_CLAW_ANG: {
        -: 1779:        // Deserialize opcode
        -: 1780:        FwOpcodeType opCode;
       34: 1781:        deserStatus = msg.deserialize(opCode);
       34: 1782:        FW_ASSERT (
        -: 1783:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1784:            static_cast<AssertArg>(deserStatus)
        -: 1785:        );
        -: 1786:
        -: 1787:        // Deserialize command sequence
        -: 1788:        U32 cmdSeq;
       34: 1789:        deserStatus = msg.deserialize(cmdSeq);
       34: 1790:        FW_ASSERT (
        -: 1791:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1792:            static_cast<AssertArg>(deserStatus)
        -: 1793:        );
        -: 1794:
        -: 1795:        // Deserialize command argument buffer
       68: 1796:        Fw::CmdArgBuffer args;
       34: 1797:        deserStatus = msg.deserialize(args);
       34: 1798:        FW_ASSERT (
        -: 1799:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1800:            static_cast<AssertArg>(deserStatus)
        -: 1801:        );
        -: 1802:
        -: 1803:        // Reset buffer
       34: 1804:        args.resetDeser();
        -: 1805:
        -: 1806:        // Deserialize argument angle
        -: 1807:        F32 angle;
       34: 1808:        deserStatus = args.deserialize(angle);
       34: 1809:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 1810:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 1811:            this->cmdResponse_out(
        -: 1812:                opCode,
        -: 1813:                cmdSeq,
        -: 1814:                Fw::COMMAND_FORMAT_ERROR
        -: 1815:            );
        -: 1816:          }
        -: 1817:          // Don't crash the task if bad arguments were passed from the ground
    #####: 1818:          break;
        -: 1819:        }
        -: 1820:
        -: 1821:        // Make sure there was no data left over.
        -: 1822:        // That means the argument buffer size was incorrect.
        -: 1823:#if FW_CMD_CHECK_RESIDUAL
       34: 1824:        if (args.getBuffLeft() != 0) {
    #####: 1825:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 1826:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 1827:          }
        -: 1828:          // Don't crash the task if bad arguments were passed from the ground
    #####: 1829:          break;
        -: 1830:        }
        -: 1831:#endif
        -: 1832:        // Call handler function
       34: 1833:        this->AA_CLAW_ANG_cmdHandler(
        -: 1834:            opCode,
        -: 1835:            cmdSeq,
        -: 1836:            angle
       34: 1837:        );
        -: 1838:
       34: 1839:        break;
        -: 1840:
        -: 1841:      }
        -: 1842:
        -: 1843:      // Handle command AA_BASE_ANG
       22: 1844:      case CMD_AA_BASE_ANG: {
        -: 1845:        // Deserialize opcode
        -: 1846:        FwOpcodeType opCode;
       22: 1847:        deserStatus = msg.deserialize(opCode);
       22: 1848:        FW_ASSERT (
        -: 1849:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1850:            static_cast<AssertArg>(deserStatus)
        -: 1851:        );
        -: 1852:
        -: 1853:        // Deserialize command sequence
        -: 1854:        U32 cmdSeq;
       22: 1855:        deserStatus = msg.deserialize(cmdSeq);
       22: 1856:        FW_ASSERT (
        -: 1857:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1858:            static_cast<AssertArg>(deserStatus)
        -: 1859:        );
        -: 1860:
        -: 1861:        // Deserialize command argument buffer
       44: 1862:        Fw::CmdArgBuffer args;
       22: 1863:        deserStatus = msg.deserialize(args);
       22: 1864:        FW_ASSERT (
        -: 1865:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1866:            static_cast<AssertArg>(deserStatus)
        -: 1867:        );
        -: 1868:
        -: 1869:        // Reset buffer
       22: 1870:        args.resetDeser();
        -: 1871:
        -: 1872:        // Deserialize argument angle
        -: 1873:        F32 angle;
       22: 1874:        deserStatus = args.deserialize(angle);
       22: 1875:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 1876:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 1877:            this->cmdResponse_out(
        -: 1878:                opCode,
        -: 1879:                cmdSeq,
        -: 1880:                Fw::COMMAND_FORMAT_ERROR
        -: 1881:            );
        -: 1882:          }
        -: 1883:          // Don't crash the task if bad arguments were passed from the ground
    #####: 1884:          break;
        -: 1885:        }
        -: 1886:
        -: 1887:        // Make sure there was no data left over.
        -: 1888:        // That means the argument buffer size was incorrect.
        -: 1889:#if FW_CMD_CHECK_RESIDUAL
       22: 1890:        if (args.getBuffLeft() != 0) {
    #####: 1891:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 1892:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 1893:          }
        -: 1894:          // Don't crash the task if bad arguments were passed from the ground
    #####: 1895:          break;
        -: 1896:        }
        -: 1897:#endif
        -: 1898:        // Call handler function
       22: 1899:        this->AA_BASE_ANG_cmdHandler(
        -: 1900:            opCode,
        -: 1901:            cmdSeq,
        -: 1902:            angle
       22: 1903:        );
        -: 1904:
       22: 1905:        break;
        -: 1906:
        -: 1907:      }
        -: 1908:
        -: 1909:      // Handle command AA_ARM_HEIGHT_ANG
       18: 1910:      case CMD_AA_ARM_HEIGHT_ANG: {
        -: 1911:        // Deserialize opcode
        -: 1912:        FwOpcodeType opCode;
       18: 1913:        deserStatus = msg.deserialize(opCode);
       18: 1914:        FW_ASSERT (
        -: 1915:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1916:            static_cast<AssertArg>(deserStatus)
        -: 1917:        );
        -: 1918:
        -: 1919:        // Deserialize command sequence
        -: 1920:        U32 cmdSeq;
       18: 1921:        deserStatus = msg.deserialize(cmdSeq);
       18: 1922:        FW_ASSERT (
        -: 1923:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1924:            static_cast<AssertArg>(deserStatus)
        -: 1925:        );
        -: 1926:
        -: 1927:        // Deserialize command argument buffer
       36: 1928:        Fw::CmdArgBuffer args;
       18: 1929:        deserStatus = msg.deserialize(args);
       18: 1930:        FW_ASSERT (
        -: 1931:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1932:            static_cast<AssertArg>(deserStatus)
        -: 1933:        );
        -: 1934:
        -: 1935:        // Reset buffer
       18: 1936:        args.resetDeser();
        -: 1937:
        -: 1938:        // Deserialize argument angle
        -: 1939:        F32 angle;
       18: 1940:        deserStatus = args.deserialize(angle);
       18: 1941:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 1942:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 1943:            this->cmdResponse_out(
        -: 1944:                opCode,
        -: 1945:                cmdSeq,
        -: 1946:                Fw::COMMAND_FORMAT_ERROR
        -: 1947:            );
        -: 1948:          }
        -: 1949:          // Don't crash the task if bad arguments were passed from the ground
    #####: 1950:          break;
        -: 1951:        }
        -: 1952:
        -: 1953:        // Make sure there was no data left over.
        -: 1954:        // That means the argument buffer size was incorrect.
        -: 1955:#if FW_CMD_CHECK_RESIDUAL
       18: 1956:        if (args.getBuffLeft() != 0) {
    #####: 1957:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 1958:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 1959:          }
        -: 1960:          // Don't crash the task if bad arguments were passed from the ground
    #####: 1961:          break;
        -: 1962:        }
        -: 1963:#endif
        -: 1964:        // Call handler function
       18: 1965:        this->AA_ARM_HEIGHT_ANG_cmdHandler(
        -: 1966:            opCode,
        -: 1967:            cmdSeq,
        -: 1968:            angle
       18: 1969:        );
        -: 1970:
       18: 1971:        break;
        -: 1972:
        -: 1973:      }
        -: 1974:
        -: 1975:      // Handle command AA_ARM_LENGTH_ANG
       12: 1976:      case CMD_AA_ARM_LENGTH_ANG: {
        -: 1977:        // Deserialize opcode
        -: 1978:        FwOpcodeType opCode;
       12: 1979:        deserStatus = msg.deserialize(opCode);
       12: 1980:        FW_ASSERT (
        -: 1981:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1982:            static_cast<AssertArg>(deserStatus)
        -: 1983:        );
        -: 1984:
        -: 1985:        // Deserialize command sequence
        -: 1986:        U32 cmdSeq;
       12: 1987:        deserStatus = msg.deserialize(cmdSeq);
       12: 1988:        FW_ASSERT (
        -: 1989:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1990:            static_cast<AssertArg>(deserStatus)
        -: 1991:        );
        -: 1992:
        -: 1993:        // Deserialize command argument buffer
       24: 1994:        Fw::CmdArgBuffer args;
       12: 1995:        deserStatus = msg.deserialize(args);
       12: 1996:        FW_ASSERT (
        -: 1997:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1998:            static_cast<AssertArg>(deserStatus)
        -: 1999:        );
        -: 2000:
        -: 2001:        // Reset buffer
       12: 2002:        args.resetDeser();
        -: 2003:
        -: 2004:        // Deserialize argument angle
        -: 2005:        F32 angle;
       12: 2006:        deserStatus = args.deserialize(angle);
       12: 2007:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2008:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2009:            this->cmdResponse_out(
        -: 2010:                opCode,
        -: 2011:                cmdSeq,
        -: 2012:                Fw::COMMAND_FORMAT_ERROR
        -: 2013:            );
        -: 2014:          }
        -: 2015:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2016:          break;
        -: 2017:        }
        -: 2018:
        -: 2019:        // Make sure there was no data left over.
        -: 2020:        // That means the argument buffer size was incorrect.
        -: 2021:#if FW_CMD_CHECK_RESIDUAL
       12: 2022:        if (args.getBuffLeft() != 0) {
    #####: 2023:          if (this->m_CmdStatus_OutputPort[0].isConnected()) {
    #####: 2024:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2025:          }
        -: 2026:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2027:          break;
        -: 2028:        }
        -: 2029:#endif
        -: 2030:        // Call handler function
       12: 2031:        this->AA_ARM_LENGTH_ANG_cmdHandler(
        -: 2032:            opCode,
        -: 2033:            cmdSeq,
        -: 2034:            angle
       12: 2035:        );
        -: 2036:
       12: 2037:        break;
        -: 2038:
        -: 2039:      }
        -: 2040:
    #####: 2041:      default:
    #####: 2042:        return MSG_DISPATCH_ERROR;
        -: 2043:
        -: 2044:    }
        -: 2045:
      837: 2046:    return MSG_DISPATCH_OK;
        -: 2047:
        -: 2048:  }
        -: 2049:
       54: 2050:} // end namespace RobotArm
